🔔목차🔔

- [자바스크립트의 역할](#자바스크립트의-역할)
- [자바스크립트 코드 작성법](#자바스크립트-코드-작성법)
- [변수와 식별자](#변수와-식별자)
  - [변수](#변수)
  - [식별자](#식별자)
  - [조건문](#조건문)
    - [while](#while)
    - [for, for ... in, for ... of](#for-for--in-for--of)
    - [식별자 정의와 특징](#식별자-정의와-특징)
  - [주석](#주석)
- [함수](#함수)
  - [기본 인자](#기본-인자)
  - [전개 구문(Spread syntax)](#전개-구문spread-syntax)
  - [선언식과 표현식](#선언식과-표현식)


# 자바스크립트의 역할

- 웹 브라우저는 사용자에게 보여 줄 화면을 설정함(클라이언트 역할)

# 자바스크립트 코드 작성법

1. 세미콜론(;)

- Javascript는 세미콜론을 선택적으로 사용 가능
- 세미콜론이 없는 경우 ASI(자동 세미콜론 삽입 규칙)에 의해 자동으로 세미콜론이 삽입됨
- 최근에는 세미콜론을 아예 안 쓰는 추세(자동에 맡기자)

2. 들여쓰기와 코드 블록

- javascript는 2칸 들여쓰기 사용 권장(python은 4칸)
- block은 중괄호{}로 구분(python은 들여쓰기)

3. 코드 스타일 가이드

- 코드의 품질에 직결되는 요소
- 합의된 원칙과 일관성이 중요
- 회사 별로 스타일 가이드가 다름

# 변수와 식별자

## 변수

1. let

- 재할당은 가능하지만 재선언은 불가
- 초기값이 없어도 선언 가능
- 중괄호 기준 블록 스코프 보유

```javascript
let number = 20
number  = 10    // 재할당(가능)

let number = 20
let number = 10 // 재선언(불가)
```

2. const

- 재할당, 재선언 모두 불가
    - 재할당, 재선언 시도 시 오류 발생

- 선언 시 반드시 초기 값을 설정해 주어야 함
- 중괄호 기준 블록 스코프 보유

3. var

- 재할당, 재선언 가능
- *호이스팅* 되는 특성으로 인해 예기치 못한 문제가 발생할 수 있음
  - 최신 버전의 Javascript에서는 var 대신 const와 let을 사용하는 것이 권장된다.

- 함수 스코프(function scope) 보유

*호이스팅 : 변수 선언 이전에 참조할 수 있는 현상, 변수를 var로 선언하는 경우 변수 출력 값이 의도하지 않은 값이 될 가능성이 높아짐*

4. string

- Template Literal을 사용하면 줄바꿈이 되며, 문자열 사이에 변수 삽입 가능
- backtick(`) 사용
- 표현식은 ${} 사용

```javascript
const age = 20
const message = `홍길동은 ${age}세입니다.`
```

5. empty value

- null와 undefined 모두 사용
- 유연하게 사용 가능하나 일정한 규칙을 가지고 사용하는 것이 권장됨
  - null : 빈 값임을 의도적으로 표현할 때 사용
  - undefined : 값이 아직 정의되지 않았음을 표현할 때 사용(직접 할당되지 않는 경우 자동으로 할당되는 빈 값)

## 식별자

- 변수를 구분할 수 있는 변수명
- 문자, $, 밑줄(_)로 시작
- 대소문자 구분, 클래스명 이외에는 소문자로 시작
- 예약어(for, if, function 등) 사용 불가

6. 비교 연산자

- 결과를 Boolean(True or False) 타입으로 반환함
- 동등 연산자(==)의 경우 비교 시 암묵적 타입 변환
    - 메모리가 같은 객체를 가리키는지 평가
    - 특별한 경우를 제외하고 사용하지 않음

- 파이썬의 == 처럼 사용하려면 일치 연산자(===)를 사용하면 됨
  - 같은 객체, 같은 타입, 같은 값인지 비교(엄격한 비교)
  - 암묵적 타입 변화가 발생하지 않음

7. 논리 연산자

- and : &&

- or : ||

- not : !

- 단축 평가 지원(앞부분이 False이면 뒤쪽의 진위 여부는 평가하지 않음)

8. 삼항 연산자

- 조건식의 진위 여부에 따라 콜론을 기준으로 왼쪽 값이, 거짓이면 오른쪽 값이 반환됨
- 삼항 연산자의 결과는 변수에 할당도 가능

```javascript
true ? 1 : 2
false ? 1 : 2

const result = Math.PI > 4 ?    // 'Yep' : 'Nope'
console.log(result)    // Nope
```

## 조건문

- if, else if, else 사용
    - 조건은 소괄호 안에 작성
    - 실행할 코드는 중괄호 안에 작성
    - 블록 스코프 생성

```javascript
const name = 'manager'

if (name === 'admin') {
    console.log('관리자님 환영합니다.')
} else if (name === 'manager') {
    console.log('매니저님 환영합니다.')
} else {
    console.log(`${name}님 환영합니다`)
}
```

- switch
  - 표현식의 결과값을 이용한 조건문
  - 표현식의 결과값과 case문의 오른쪽 값 비교
  - break, default 구문은 선택 사항
  - break가 없는 경우 break를 만나거나 default를 실행할 때까지 다음 조건문 실행
  - 블록 스코프 생성

```javascript
const name = 'manager'

switch (name) {
    case '홍길동' : {
        console.log('홍길동님 환영합니다.')
        break
    }
    case 'manager' : {
    console.log('매니저님 환영합니다.')
    break
    } 
    default {
    console.log(`${name}님 환영합니다`)
    }
}
```

- 위 사례의 경우 중간 중간에 break가 없으면 모든 구문이 출력됨(fall through)
- fall through 현상을 방지하려면 중간에 break문을 삽입해야 함

- 조건이 많은 경우 switch로 구현하는 게 유리

### while

- while은 python의 while과 동일(조건을 충족하는 한 반복 실행)


### for, for ... in, for ... of

```javascript
for (condition) {
  statement
}

for (condition in array) {
  statement
}

for (condition of array) {
  statement
}
```

- for의 경우 특정 조건문이 거짓으로 판별될 때까지 반복
  - 반복 범위를 조건문으로 제한하는 방식
  - for ([초기문]; [조건문]; [증감문]) { 행위 } 로 구성

- for ... in의 경우 객체(object)의 속성을 순회할 때 사용
  - 배열을 순회하는 경우 인덱스 순으로 순회한다는 보장이 없다.
  - 배열을 순회하려 하는 경우 for ... of 를 사용하는 것이 권장된다.
  - 속성 이름을 반복

- for ... of는 반복 가능한 객체를 순회할 때 사용
  - 반복 가능한 객체 : Array, Set, String 등
  - 속성 값을 반복

### 식별자 정의와 특징

1. 카멜 케이스(camelCase) - 권장
 
- 변수, 객체, 함수에 사용

2. 파스칼 케이스(PascalCase)

- 클래스, 생성자에 사용

3. 대문자 스네이크 케이스(SNAKE_CASE)

- 상수(constants)에 사용
- 개발자의 의도와 관계 없이 변동될 가능성이 거의 없는 경우

## 주석

- 한 줄 주석은 //
- 여러 줄 주석은 /* */
  - vsc 자동완성 기능을 사용하면 여러 줄 도 한 줄 주석처럼 할 수 있음

```javascript
// 한 줄 주석

/*
여러 줄 주석
여러 줄 주석
여러 줄 주석
*/

// 한 줄 주석 기능으로
// 여러 줄 주석도 가능
```

# 함수

- 참조 타입의 일종으로 function 타입에 속한다.
- javascript에서 함수를 정의하는 방법은 함수 선언식과 함수 표현식으로 구분된다.

1. 함수 선언식

- 일반적인 프로그래밍 언어의 함수 정의 방식

```javascript
function add(num1, num2) {
  return num1 + num2
}
```

2. 함수 표현식

- 표현식 내에서 함수를 정의하는 방식
  - 함수 표현식은 익명 함수로 정의 가능
  - 함수명 = function()으로 표시

```javascript
const sub = function(num1, num2) {
  return num1 - num2
}
```

- 표현식에서 함수명을 명시하는 것도 가능하나, 이 경우 해당 함수명은 호출에 사용할 수 없다.
  - 주로 디버깅 할 때 사용하는 방식

```javascript
const mySub = function namedSub(num1, num2) {
  return num1 - num2
}

mySub(1, 2)  // -1
namedSub(1, 2)  // ReferenceError : nameSub is not defined
```

## 기본 인자

- 인자 작성 시 '=' 뒤에 기본 인자 선언 가능
- 매개 변수보다 인자의 개수가 많을 경우 개수가 초과하는 뒷부분은 자동 탈락
- 매개 변수보다 인자 개수가 적을 경우 자동으로 undefined 값이 입력됨

```javascript
const greeting = function(name = 'Anonymous') {
  return `Hi ${name}`
}
```

## 전개 구문(Spread syntax)

- (배열, 문자열 등) 반복 가능한 객체를 요소(배열의 경우)나 인자(함수의 경우)로 확장 가능

```javascript
let parts = ['shoulder', 'knee']
let lyrics = ['head', ...parts, 'toe']
// lyrics = ['head', 'shoulder', 'knee', 'toe']
```

```javascript
function func(a, b, ...theArgs) {
  return [arg1, arg2, theArgs]
}

func(1, 2, 3, 4, 5)  // [1, 2, [3, 4, 5]]
func(1, 2)  // [1, 2, []]
```

## 선언식과 표현식

- 선언식 함수와 표현식 함수의 타입은 모두 동일(function)
  - 선언식으로 정의한 함수는 호이스팅 발생(함수 호출 이전에 선언해도 동작)
  - 표현식으로 정의한 함수는 변수 취급(변수 스코프의 규칙에 따르며, 호이스팅이 발생하지 않는다.)