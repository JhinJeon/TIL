# 임베디드 트렌드

## SoC(System-on-Chip)

- 시스템의 핵심 기능의 일부 또는 전부가 칩 안에 내장된 형태의 설계
  - 핵심 기능 : CPU, 메모리, UART, 파워 등...
- SoC 위에서 동작하는 SW가 펌웨어(Firmware)

## 프로세스 유닛(MPU)

- 32비트 단위 프로세서 : 고성능 고수준 작업 수행 가능, 스마트폰에 탑재
  - 단일 칩셋에 들어가는 동작이 증가했다.
  - 규모가 커진 만큼 개발 역량 중요성 증가

## **MCU와 MPU의 차이** 

- MCU는 가상 메모리 구성이 불가능하고, MPU는 가상 메모리 구성이 가능하다.
- MPU 작동을 위해서는 메모리 관리 유닛(MMU)가 필요하다.
- MPU는 운영체제 및 기본 시스템 구성에 적합하고, MCU는 시스템의 특정 작업을 구현하는 데 유리하다.

## 임베디드 프로그래밍

- 임베디드 프로그래밍은 임베디드와 펌웨어가 통합되어 복잡해지는 추세
- 임베디드 개발에 착수하기 전부터 제품 종류와 HW개발 방향부터 정해야 한다.

# 임베디드 교육 목표

- 제어나 명령 등을 통해 장치의 어느 부분에서 동작하는지 이해할 수 있어야 한다.

# ARM

- CPU 계열은 다양한 종류의 코어들이 있다.
- RISC : 명령어 개수를 줄여 HW구조를 단순하게 만든 형태(ARM)
- ARM은 CPU 코어를 변경할 수 있는 라이센스와 그대로 사용해야 하는 라이센스를 제공한다.
  - (퀄컴, 애플 등이 ARM 라이센스를 바탕으로 자체 칩 개발)
- CISC : 복잡한 명령어 집합을 갖는 CPU 아키텍처(x86)
- 임베디드의 개발의 경우 ARM 기반의 마이크로프로세서를 취급한다.
- 32비트, 64비트 지원

## ARM 코어 종류

- Cortex-A
- Cortex-R : 실시간 서비스에 특화된 코어
- Cortex-M : 마이크로프로세서(임베디드 디바이스)용 코어

> - 듀얼 코어인 경우 두 코어가 동시에 작동하지 않는다.(신뢰성 확보를 위함) 
> - 한 쪽이 락다운이 걸리는 경우를 대비해서 예비 코어로 사용한다.

- trustzone : 보안 영역

# 프로세서 구조

- 성능이 향상될수록 블록에 장치들이 많이 들어간다(칩셋 등).
- 어셈블리의 경우 : 성능이 높을수록 호환성이 낮아진다.

# STM32

- STM(전자제품 및 반도체 제조사)에서 제공하는 마이크로컨트롤러 제품군
- 32비트 ARM Cortex-M 프로세서 코어 설계 사용

## 제품군 선택

- 현업에는 F1(F시리즈), L1(L시리즈) 등 구형 장비를 사용하는 경우도 많다.
- 다만 U5, G5 등 신형 제품들도 출시되고 있다.
- 구형 제품은 공급 이슈에 민감하고, 신형 제품이라고 무조건 비싼 건 아니다.
- 디바이스 선정 이전에 제품 별 제작 시기와 주 용도를 확인하는 것이 좋다.
- ST에서는 산업용으로 쓰이는 제품 들은 출시 후 최소 10년간은 생산(공급)을 보장한다.
  - 다만 일반 소비자용은 불시에 단종될 수 있다.
  
- HW개발자와 함께 부품의 종합적인 라이프사이클을 고려하여 제품을 선택해야 한다. 


## 범용성/호환성 고려

- Standard Library : 기본 라이브러리 설명(구형)
- High Library : 서로 다른 장치 간 호환성을 높이기 위해 등장
- LL(Low level) Library : High Library보다 더 높은 수준의 효율성과 호환성 추구

# STM32 CubeIDE

- Eclipse 기반 IDE Tool
- 국내에서 가장 범용적으로 사용하는 임베디드 개발 툴이다.
- CubeIDE로 제작한 프로젝트는 CubeIDE 전용으로만 사용 가능하다.
- 별도의 컴파일러를 사용하려면 CubeIDE를 이용해 따로 Makefile을 생성해야 한다.

## 환경 설졍

1. STM32 CubeIDE, CubeMX 설치
2. Help > Embedded Software Package Manager > 필요한 SDK 라이브러리 불러오기


## CubeMX 다루기

- 가격, 코어, 프로세서 등 원하는 사양을 입력하면 조건에 부합하는 제품 필터링
- 시리즈 별로 다양한 종류의 제품들이 있다.

### SDK(소프트웨어 개발 킷) 다운로드

- MX에서 제품 선택 > 상단 탭에 Docs&Resources > 다운로드 및 열람
- 핀아웃 뷰 제공
- Project Manager 탭에 들어가면 코드 작성과 장치 상태 모니터링 가능

### 펌웨어 업데이트

- IDE에서 Firmware Updater에서 다운로드 경로 설정
- 기본 위치는 /STM32/Repository

### 새 프로젝트 생성

- File/New/STM32 Project > Board Selector > 보드명 선택 > 프로젝트명 작성 및 설정
- Board Selector를 선택하면 사용할 보드의 회로 및 핀 값을 가져온다.
  - periperal mode에서 yes를 선택하면 모든 설정된 값으로, no를 선택하면 일부 설정값을 가져온다.
  - ST에 기본 설정되지 않은 커스텀 보드를 생성할 수도 있다.

- 보드 구성을 잘 모르는 경우 기본 보드 설정값을 가져와서 비교하면 도움이 된다.

# RTOS(실시간 운영 체제)

# 보드 실습(STM32L4S5VIT6 MCU 사용)

- 새 프로젝트 생성 시 보드에 맞는 SDK를 다운로드
- 프로젝트 생성 후 project_name.loc 파일에 들어가면 디바이스의 클럭 트리 리스트 표시
  - 클럭을 높이면 처리속도가 증가하는 대신 전력 소모량 증가
  - 클럭을 줄이면 전력 소모량이 감소하는 대신 처리속도 감소

- **레퍼런스 매뉴얼 : help > Target Devices Docs and Resources > Reference Manuals**

## 코드 생성(모듈 커스터마이징)

- code generation 아이콘 or project > generate code

## LED 점등시켜 보기

- LED가 점등되면 MCU 구동 준비가 완료되었다는 뜻(Hello World 출력하는 것과 동급)
- 보드의 회로도를 보면 LED와 관련된 부분을 파악할 수 있다.
  - 펌웨어 개발자는 회로도를 볼 수 있어야 한다.
  - 실습 보드는 PB14번 핀에서 LED 점등을 관장한다.

### SDK 설정

- PB14번 핀에서 전기를 내보낼 것이므로 GPIO_Output을 설정한다.
- 이후 빌드를 하면(망치 아이콘 또는 Build Project) 실행 파일을 생성한다.
- USB로 연결하는 경우 보드에 HW 디버거에 파일을 옮기면(명령을 하면) MCU에 파일 데이터를 전송한다.

### 빌드하기

- 코드 작성 시 'User Code Begin 3' 주석 아래에 써야 코딩한 내용이 사라지지 않는다.
  - main.c, system.c 등 Tool이 기본적으로 만들어 준 파일은 자체적으로 초기화하므로, 빌드 시 데이터를 버리지 않으려면 User code 주석 아래 넣어야 한다. 

### 보드로 실행 파일 옮기기

- 디버거를 통해서 MCU에 쓰기(write)를 해야 하므로, 유닛의 가장자리 쪽 포트에 연결한다.
- 디버깅하려면 벌레 아이콘 또는 Run / Debug를 클릭한다.
  - 문제가 발생하면 코드에서 Breakpoint가 걸린다.

### 인터럽트

- 인터럽트 컨트롤러와 구현 방식은 디바이스마다 상이하다.
- 다만 Cortex-M 코어 기반으로 제작한 장비는 동일한 인터럽트 컨트롤러를 사용한다.
- Vectored 인터럽트 컨트롤러 : 각 인터럽트를 미리 정의해둔 후 해당 인터럽트에 맞춰서 만든 인터럽트를 찾아 처리하는 방식
  - 인터럽트 핸들링 값을 얻어서 해당 값을 바탕으로 인터럽트 간접 제어, 인터럽트 간 우선순위 존재
- 스택 포인터가 0번이면 초기화 함수를 C언어로 작성할 수 있다.

### Weak Function(약한 연결)

- C/C++ 에서 목적 파일들을 링크할 때 심볼간의 우선 순위 조정

# UART 통신

- HAL_OK, ERROR(오류 처리), BUSY(대기), TIMEOUT 설정