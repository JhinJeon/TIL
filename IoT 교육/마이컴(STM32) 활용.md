# 임베디드 트렌드

## SoC(System-on-Chip)

- 시스템의 핵심 기능의 일부 또는 전부가 칩 안에 내장된 형태의 설계
  - 핵심 기능 : CPU, 메모리, UART, 파워 등...
- SoC 위에서 동작하는 SW가 펌웨어(Firmware)

## 프로세스 유닛(MPU)

- 32비트 단위 프로세서 : 고성능 고수준 작업 수행 가능, 스마트폰에 탑재
  - 단일 칩셋에 들어가는 동작이 증가했다.
  - 규모가 커진 만큼 개발 역량 중요성 증가

## **MCU와 MPU의 차이** 

- MCU는 가상 메모리 구성이 불가능하고, MPU는 가상 메모리 구성이 가능하다.
- MPU 작동을 위해서는 메모리 관리 유닛(MMU)가 필요하다.
- MPU는 운영체제 및 기본 시스템 구성에 적합하고, MCU는 시스템의 특정 작업을 구현하는 데 유리하다.

## 임베디드 프로그래밍

- 임베디드 프로그래밍은 임베디드와 펌웨어가 통합되어 복잡해지는 추세
- 임베디드 개발에 착수하기 전부터 제품 종류와 HW개발 방향부터 정해야 한다.

# 임베디드 교육 목표

- 제어나 명령 등을 통해 장치의 어느 부분에서 동작하는지 이해할 수 있어야 한다.

# ARM

- CPU 계열은 다양한 종류의 코어들이 있다.
- RISC : 명령어 개수를 줄여 HW구조를 단순하게 만든 형태(ARM)
- ARM은 CPU 코어를 변경할 수 있는 라이센스와 그대로 사용해야 하는 라이센스를 제공한다.
  - (퀄컴, 애플 등이 ARM 라이센스를 바탕으로 자체 칩 개발)
- CISC : 복잡한 명령어 집합을 갖는 CPU 아키텍처(x86)
- 임베디드의 개발의 경우 ARM 기반의 마이크로프로세서를 취급한다.
- 32비트, 64비트 지원

## ARM 코어 종류

- Cortex-A
- Cortex-R : 실시간 서비스에 특화된 코어
- Cortex-M : 마이크로프로세서(임베디드 디바이스)용 코어

> - 듀얼 코어인 경우 두 코어가 동시에 작동하지 않는다.(신뢰성 확보를 위함) 
> - 한 쪽이 락다운이 걸리는 경우를 대비해서 예비 코어로 사용한다.

- trustzone : 보안 영역

# 프로세서 구조

- 성능이 향상될수록 블록에 장치들이 많이 들어간다(칩셋 등).
- 어셈블리의 경우 : 성능이 높을수록 호환성이 낮아진다.

# STM32

- STM(전자제품 및 반도체 제조사)에서 제공하는 마이크로컨트롤러 제품군
- 32비트 ARM Cortex-M 프로세서 코어 설계 사용

## 제품군 선택

- 현업에는 F1(F시리즈), L1(L시리즈) 등 구형 장비를 사용하는 경우도 많다.
- 다만 U5, G5 등 신형 제품들도 출시되고 있다.
- 구형 제품은 공급 이슈에 민감하고, 신형 제품이라고 무조건 비싼 건 아니다.
- 디바이스 선정 이전에 제품 별 제작 시기와 주 용도를 확인하는 것이 좋다.
- ST에서는 산업용으로 쓰이는 제품 들은 출시 후 최소 10년간은 생산(공급)을 보장한다.
  - 다만 일반 소비자용은 불시에 단종될 수 있다.
  
- HW개발자와 함께 부품의 종합적인 라이프사이클을 고려하여 제품을 선택해야 한다. 


## 범용성/호환성 고려

- Standard Library : 기본 라이브러리 설명(구형)
- High Library : 서로 다른 장치 간 호환성을 높이기 위해 등장
- LL(Low level) Library : High Library보다 더 높은 수준의 효율성과 호환성 추구

# STM32 CubeIDE

- Eclipse 기반 IDE Tool
- 국내에서 가장 범용적으로 사용하는 임베디드 개발 툴이다.
- CubeIDE로 제작한 프로젝트는 CubeIDE 전용으로만 사용 가능하다.
- 별도의 컴파일러를 사용하려면 CubeIDE를 이용해 따로 Makefile을 생성해야 한다.

## 환경 설졍

1. STM32 CubeIDE, CubeMX 설치
2. Help > Embedded Software Package Manager > 필요한 SDK 라이브러리 불러오기


## CubeMX 다루기

- 가격, 코어, 프로세서 등 원하는 사양을 입력하면 조건에 부합하는 제품 필터링
- 시리즈 별로 다양한 종류의 제품들이 있다.

### SDK(소프트웨어 개발 킷) 다운로드

- MX에서 제품 선택 > 상단 탭에 Docs&Resources > 다운로드 및 열람
- 핀아웃 뷰 제공
- Project Manager 탭에 들어가면 코드 작성과 장치 상태 모니터링 가능

### 펌웨어 업데이트

- IDE에서 Firmware Updater에서 다운로드 경로 설정
- 기본 위치는 /STM32/Repository

### 새 프로젝트 생성

- File/New/STM32 Project > Board Selector > 보드명 선택 > 프로젝트명 작성 및 설정
- Board Selector를 선택하면 사용할 보드의 회로 및 핀 값을 가져온다.
  - periperal mode에서 yes를 선택하면 모든 설정된 값으로, no를 선택하면 일부 설정값을 가져온다.
  - ST에 기본 설정되지 않은 커스텀 보드를 생성할 수도 있다.

- 보드 구성을 잘 모르는 경우 기본 보드 설정값을 가져와서 비교하면 도움이 된다.

# RTOS(실시간 운영 체제)

# 보드 실습(STM32L4S5VIT6 MCU 사용)

- 새 프로젝트 생성 시 보드에 맞는 SDK를 다운로드
- 프로젝트 생성 후 project_name.loc 파일에 들어가면 디바이스의 클럭 트리 리스트 표시
  - 클럭을 높이면 처리속도가 증가하는 대신 전력 소모량 증가
  - 클럭을 줄이면 전력 소모량이 감소하는 대신 처리속도 감소

- **레퍼런스 매뉴얼 : help > Target Devices Docs and Resources > Reference Manuals**

## 코드 생성(모듈 커스터마이징)

- code generation 아이콘 or project > generate code

## LED 점등시켜 보기

- LED가 점등되면 MCU 구동 준비가 완료되었다는 뜻(Hello World 출력하는 것과 동급)
- 보드의 회로도를 보면 LED와 관련된 부분을 파악할 수 있다.
  - 펌웨어 개발자는 회로도를 볼 수 있어야 한다.
  - 실습 보드는 PB14번 핀에서 LED 점등을 관장한다.

### SDK 설정

- PB14번 핀에서 전기를 내보낼 것이므로 GPIO_Output을 설정한다.
- 이후 빌드를 하면(망치 아이콘 또는 Build Project) 실행 파일을 생성한다.
- USB로 연결하는 경우 보드에 HW 디버거에 파일을 옮기면(명령을 하면) MCU에 파일 데이터를 전송한다.

### 빌드하기

- 코드 작성 시 'User Code Begin 3' 주석 아래에 써야 코딩한 내용이 사라지지 않는다.
  - main.c, system.c 등 Tool이 기본적으로 만들어 준 파일은 자체적으로 초기화하므로, 빌드 시 데이터를 버리지 않으려면 User code 주석 아래 넣어야 한다. 

### 보드로 실행 파일 옮기기

- 디버거를 통해서 MCU에 쓰기(write)를 해야 하므로, 유닛의 가장자리 쪽 포트에 연결한다.
- 디버깅하려면 벌레 아이콘 또는 Run / Debug를 클릭한다.
  - 문제가 발생하면 코드에서 Breakpoint가 걸린다.

### 인터럽트

- 인터럽트 컨트롤러와 구현 방식은 디바이스마다 상이하다.
- 다만 Cortex-M 코어 기반으로 제작한 장비는 동일한 인터럽트 컨트롤러를 사용한다.
- Vectored 인터럽트 컨트롤러 : 각 인터럽트를 미리 정의해둔 후 해당 인터럽트에 맞춰서 만든 인터럽트를 찾아 처리하는 방식
  - 인터럽트 핸들링 값을 얻어서 해당 값을 바탕으로 인터럽트 간접 제어, 인터럽트 간 우선순위 존재
- 스택 포인터가 0번이면 초기화 함수를 C언어로 작성할 수 있다.

### Weak Function(약한 연결)

- C/C++ 에서 목적 파일들을 링크할 때 심볼간의 우선 순위 조정

# UART 통신

- HAL_OK, ERROR(오류 처리), BUSY(대기), TIMEOUT 설정

## NVIC 설정

- ST IOC > System Core > NVIC > USART global interrupt 적용 체크
- 이후 main() 함수의 while() 안에 코드 작성

```c
    // UART 통신 수신 함수)
	  HAL_UART_Receive_IT(&huart1, &a, 1);
```

## 출력 설정

- STM32에서는 기본적인 표준 출력이 없다.
- printf, UART 등 출력 방식을 설정해주어야 한다.
- 출력 설정 변경 : syscall.c 파일에서 _write() 함수의 내용을 변경하면 된다.

```c
// gcc 라이브러리의 옵션 값 처리하는 함수
// syscalls.c
extern int __io_putchar(int ch) __attribute__((weak));
extern int __io_getchar(void) __attribute__((weak));
```
- 이후 main.c에 __io_putchar() 함수 추가

```c
// main. c
int __io_putchar(int ch)
{
	HAL_UART_Transmit(&huart1, (uint8_t*)&ch, 1, 10);
}
```

# Timer

- 클럭의 시간을 측정하는 장치(클럭을 세는 장치)
- 클럭의 출력(1초당 몇 번 똑딱이는지)을 알면 시간을 유추할 수 있다.
- Timer를 사용해야 하는 경우가 많다.
- 정확한 시간 단위를 계산하려면 타이머가 셀 수 있는 최소 클럭 단위를 맞춰 주어야 한다.(예: 1KHz인 경우 1/1000밀리초 단위까지 측정 가능)

## 타이머 구조 특징

- STM의 모든 타이머는 auto-reload register(몇 개까지 셀 것인지 설정)와 CNT counter(클럭 집계 역할)를 공통적으로 갖고 있다.
- auto-reload register와 CNT counter를 바탕으로 타이머를 세는 구조이다.(그 밖의 구조는 부가적인 기능)
  - auto-reload register에 설정한 값을 충족하면 인터럽트가 발생한다(집계를 종료하고 다른 동작 실행).
- 기본적인 기능과 구조는 Basic Timer에서 시작한다.(6번, 7번)
- prescaler : 클럭 단위를 재조정해 주는 장치
  - 예) 1000Hz의 신호가 들어왔을 때 1/10 배율로 설정(100Hz로 전환)하여 집계 단위에 맞춰 주기 
- 내가 사용하는 타이머가 어떤 클럭이 들어오는 지 알아야 한다.

# PWM(Pulse Width Modulation)

- 임의의 정해진 출력 파형을 유도하기 위해 펄스폭 또는 주파수(또는 둘 다) 변조시키는 펄스 제어 방식
- 동일한 클럭에서 펄스 폭(width)의 차이를 자유자재로 제어할 수 있다.
- 디지털 신호를 아날로그 신호처럼 만들 수 있다(CPU 팬 속도제어, DC모터 회전속도 제어 등)
  - 일정 시간 단위 동안 흐르는 전기 에너지의 평균을 계산하면(전압 등) 아날로그 신호처럼 보인다.

# STM 6축센서 사용

- 가속도 3축, 자이로스코프(기울어진 정도) 3축 측정
- ST MCU와 ST 센서를 사용하면 전용 드라이버를 설치해서 사용할 수 있다.
  - 설치 방법 : ST IDE에서 software packs > software pack components

# FreeRTOS

## FreeRTOS 개요

- Free Real-Time OS(무료 실시간 OS)의 약자이다.
- RTOS(Real-Time OS)는 멀티 프로세스(MP)를 지원하지 않는 환경에서 정확한 시간에 정확한 동작을 할 수 있는 기능을 지원해 주는 OS이다.
- 자동차 전장용품(ECU 등) 등 신뢰성과 반응성이 중요한 분야에 사용된다.

## FreeRTOS 사용 시 유의사항

- 제한된 자원이 부여된 환경에서 구동해야 하므로, 메모리 관리를 철저히 해야 한다.
- Memory Allocation을 Dynamic(메모리 동적 할당)으로 설정하면 메모리 관리 및 최적화에 도움이 된다.
- FreeRTOS를 사용한다고 해서 편의성이 항상 증가하는 것은 아니다.(사용법을 잘 알아야 함)
- (잘 만드는 경우) 싱글 스레드보다 멀티 스레드의 동작성이 훨씬 높다.

## STM32에서의 FreeRTOS

- xTaskCreate 함수로 FreeRTOS에서 실행할 동작 설정
  - 파라미터로 task에 대한 정보 제공
- osKernelStart 함수가 FreeRTOS를 구성하는 함수
- CMSIS를 구성하는 알고리즘을 소스코드 형태로 복사해준 것(커스텀 할 필요가 있지 않다면 굳이 수정할 필요는 없다.)

# CMSIS

- Cortex-Microcontroller Software Interface Standard의 약자
- SW의 호환성과 이식성을 높이기 위해 ARM이 각 협력업체와 협업하여 표준 제정 
- CMSIS의 FreeRTOS는 ST에서만 설정 가능하다(다른 회사의 IDE는 별도의 라이브러리 필요)

# V_Task task Scheduler

- task scheduler 함수를 호출하면 커널이 실행되어 유지된다.
- 커널 실행 이후 수행할 동작은 별도의 코드로 작성하여 구현한다.

# 선점형 스케쥴링

- 프로세스 별 우선순위를 설정하여, 우선순위가 높은 프로세스의 실행 조건(인터럽트 등)이 발동하면 즉시 해당 프로세스를 실행하도록 설계하는 프로그래밍
- 일반적인 RTOS들은 우선 순위를 설정할 수 있다.
  - 우선순위는 0~6단계로 나뉘며, 6에 가까울수록 우선순위가 높다.(ST 기준)

<br>
<hr>
<hr>
<hr>
<br>

# LoRa

- 비면허대역 주파수를 이용한 통신규격
  - 면허대역 통신의 경우 별도의 허가를 받아야 한다(LTE 등).

# DMA(메모리 직접 접근)

- 메모리에서 메모리로 직접 접근하여 데이터 통신, 복사 등의 기능 수행
  - 메모리 주소를 이용해 구현
- DMA를 사용하면 데이터 전송 주체는 UART가 아니라 DMA가 된다.
- 코어 제조사(ST 등)가 SoC 내에 DMA라는 하드웨어 디바이스를 탑재한 것

# 스케쥴링(Scheduling)

- 프로그램 로직이 내가 원하는 대로 작동하게 구현하는 것
- OS의 스케쥴링은 프로그램들이 내가 원하는 순서나 방식대로 동작하게 만드는 과정이다.
- OS가 있어야 스케쥴링을 할 수 있는 것은 아니다!