# 알고리즘

## 알고리즘의 정의

- 문제를 해결하기 위한 **절차**나 **방법**
- 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법

## 알고리즘 표현 방법

- 의사(pseudo) 코드
- 순서도

## 좋은 알고리즘의 기준

- 정확성
- 작업량 : 최소 연산으로 원하는 결과 도출
- 메모리 사용량
- 단순함
- 최적화

## 알고리즘의 성능 분석

- 알고리즘의 작업량을 기준으로 성능 분석

## 시간복잡도

- 실제 걸리는 시간을 측정
- 실제로 실행되는 명령문의 수를 계산
- 빅-오 표시법(Big-O Notation)
  - 시간 복잡도 함수 중 가장 큰 영향력을 주는 n에 대한 항만 표시
  - 계수는 생략
  - n이 10억(10^8)인 경우 실제 시간 0.1초

## 배열

- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

## 1차원 배열

- 변수에 처음 값을 할당할 때 생성

## 무한히 큰(작은) 수 정의

- inf, -inf를 사용하는 경우 메모리 최적화에 불리함
- 리스트 첫 번째 값을 뽑은 뒤 다른 인덱스의 값들과 비교\

## 정렬

- 자료를 특정한 기준에 따라 배열하는 것

## 버블 정렬

- 배열의 맨 앞부터 시작
- 서로 인접한 항목을 비교
  - 정렬 조건에 어긋나는 경우 인접한 항목의 위치를 교체
  - 오름차순인 경우 더 큰 값을 오른쪽에 배치
- n개의 항목을 정렬하면 인덱스 범위는 0 ~ (n-2)

## 버블 정렬 코드

- 크기가 N인 배열의 항목들을 오름차순에 따라 정렬하는 코드

```python
def Bubblesort(a, N):
    for i in range(N-1, 0, -1):
        for j in range(0,i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

## 카운팅 정렬

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- 정수형 자료(정수로 표현 가능한 자료형 포함)에만 사용 가능

## 카운팅 정렬 사용

- 정수 배열 리스트 중에서 가장 많이 등장한 숫자부터 나열할 때 사용
- 리스트 원본에서 각 항목의 횟수를 세서 별도의 배열에 기록
  - 배열에 기록할 idx:val을 중복되는 값: 중복되는 횟수로 기록
- 중복되는 숫자를 새로운 배열에 풀어서 해결하려면 중복되는 횟수만큼 새 배열에 추가

## 카운팅 정렬 알고리즘 코드

```python
def Counting_SOrt(A, B, k):
    # A는 입력 배열
    # B는 정렬된 배열
    # C는 카운트 배열
    C = [0] * (k+1)

    for i in range(0, len(A)):
        C[A[i]] += 1

    for i in range(1, len(C)):
        C[i] += C[i-1]

    for i in range(len(B)-1, -1, -1):
        C[A[i]] -= 1
        B[C[C[i]]] = A[i] 
```

## 완전 검색

- 모든 경우의 수를 가정해서 계산
- 시간과 메모리 소모가 많지만 정답을 찾을 가능성이 높음

## 순열(Permutation)

- 서로 다른 것 중 몇 개를 뽑아서 나열하는 것

## 순열 알고리즘 코드

```python
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3 != i1 and i3 != i2:
                    print(i1, i2, i3)
```

## 탐욕 알고리즘

- 최적해를 구하는 데 사용되는 근시안적 방법
- 각 선택의 시점에서 최선이라고 판단되는 것들을 선택해 나가는 방식으로 진행
- 최종 결과가 최적의 결과라는 보장은 없음

## 탐욕 알고리즘 동작 과정

1. 해 선택 : 현재 상태에서 해를 구한 후 부분해 집합에 추가
2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지(제약 조건을 위반하지 않는지) 확인
3. 해 검사 : 부분해 집합이 문제의 해가 되는지 확인(미완성인 경우 1번부터 반복)

## 탐욕 알고리즘 코드

```python
i = 0
tri = run = 0
while i < 10:
    if c[i] >= 3:   # triplete 조사 후 데이터 삭제
        c[i] -= 3
        tri += 1
        continue
    if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:   # run 조사 후 데이터 삭제
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue
    i += 1

if run + tri == 2: print("Baby Gin")
else: print("Lose")
```