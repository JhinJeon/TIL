# ARM 개발 환경

## vim 개발 환경(Linux)

- 임베디드는 기본적으로 리눅스 운영체제 기반에서 개발이 진행된다.
- vi 편집기 사용에 익숙해지는 것이 유리하다.

# gcc 컴파일

- 고수준 프로그래밍 언어를 저수준 언어(어셈블리어)로 바꾸고, 이를 기계어로 다시 변환한다.
- 어셈블리어 명령어 구성에 따라 프로그램 실행 시간 등을 최적화할 수 있다.
- 명령어 : gcc -o{level} {options} {source files} {-o output file}


## 컴파일 최적화 옵션(강의자료 15p)

- gcc -O0 : 컴파일 시간 최적화(기본)
- gcc -O1(O) : 코드 크기와 실행 시간 최적화
- gcc -O2 : 코드 크기와 실행 시간을 O1보다 최적화
- gcc -O3 : O2를 포함한 대부분의 최적화
- gcc -Os(Oz) : O2 포함 코드 크기 최적화
- gcc -Ofast : O3 포함 코드 실행 최적화
- gcc -Og : O1 포함 디버깅 코드 생성

- 명령어 마다 코드 실행시간, 코드 크기, 메모리 사용, 컴파일 소요시간 등에 장단점이 있다.
(교육 자료 기준으로 +가 많을수록 유리, -가 많을수록 불리)

- 적절한 컴파일 옵션을 사용하면 어셈블리어로 변환된 코드의 볼륨의 효율성이 증가하고, 프로그램이 최적화된다.
- 컴파일 옵션은 O2 이하를 사용하는 것이 권장된다(O3부터는 표준에 맞지 않고, 오히려 오류가 발생할 수 있음).

## 어셈블리어 분석

- push : 32비트 운영체제 환경에서 이하 명령어를 32비트 단위로 변환하는 역할
- 어셈블리어를 cat으로 조회하면 기계어가 아스키 코드 형태로 출력된다.
- build.sh 파일을 조회하면(cat) 빌드 시 사용한 명령어를 조회할 수 있다.
- 어셈블리어 명령어의 앞쪽은 오퍼레이션 명령어, 뒤쪽은 처리하려는 명령, 괄호 안에 있는 내용은 점유하는 메모리 정보
- 컴파일 시 -save-temps 옵션을 추가해야 어셈블리어가 저장된다.(저장된 어셈블리어는 cat으로 조회 및 분석 가능)

## 어셈블리어가 최적화되는 원리(p16)

- CPU 구조 및 명령처리 과정을 이해하면 도움이 된다.
- CPU는 메모리의 데이터를 가져와서 레지스터에 보관하고, 레지스터의 데이터를 ALU를 통해 실행(연산)하여 그 결과를 메모리에 저장한다.
- 데이터는 항상 메모리에 존재하므로, 메모리에 접근하는 포인터를 적절히 관리하는 것이 중요하다.
- 컴파일러 최적화는 (빌드를 통해 생성되는) 응용 프로그램이 데이터 불러오기, 연산, 저장하는 데 거치는 절차 및 횟수를 최소화하는 과정이다.

## complie explorer 활용

- compile explorer[https://godbolt.org/] 이용 시 컴파일 환경과 조건을 입력하면 어셈블리어 결과를 조회할 수 있다.

## 우선 순위(실행 순서)가 바뀌면 안 되는 경우?

- 어셈블리어의 순서가 바뀌면 하드웨어의 우선 순위가 변경될 수 있다.
- 우선 순위를 고정해야 한다면 컴파일 시 별도의 옵션을 설정해 주어야 한다.

## 변수 레지스터 초기화

- 컴파일 시 O1 옵션 설정 시 register 키워드가 붙어 있지 않아도 레지스터를 바로 사용할 수 있도록 최적화가 진행된다.
- 일반적으로 빠른 연산이 필요한 변수의 경우 register 키워드를 사용하는 것이 좋다.
- 다만 최근에는 컴파일 성능이 향상되었으므로 굳이 register 옵션을 붙이지 않아도 알아서 최적화해 줄 수 있다.

## while 반복문 최적화

- 컴파일 최적화가 진행되지 않은 경우 어셈블리어는 while의 조건문이 true인 경우와 false인 경우로 나누어서 표현한다.
- 컴파일 최적화 적용 시 조건문이 변할 수 없는(결과가 확정인) 환경인 경우 while문을 생략할 수 있다.
    - 조건문이 확정적으로 false인 경우 조건문 안의 코드를 실행하지 않아도 되므로, 최적화 시 생략된다.

## volatile 최적화

- volatile이 붙은 코드는 컴파일러 최적화를 해 주지 않는다(조건문이 false 확정인 경우에도!).
- volatile 변수는 호출될 때마다 메모리에 직접 접근하므로(레지스터를 거치지 않으므로) 컴파일 최적화 대상이 아니다.

## volatile 최적화 2: volatile 변수와 auto 변수가 같이 있는 경우

- 컴파일 최적화가 적용되지 않은 경우 모든 조건문이 어셈블리어로 번역된다.
- 컴파일 최적화가 적용된 경우, auto 변수는 false 확정 시 최적화되며, volatile 변수는 항상 컴파일된다.
- 단, volatile 변수 앞에 무한 loop 등으로 인해 변수가 실행될 일이 없는 경우 생략된다.
- **volatile 여부보다 실행 및 변경될 여지가 없는 변수/코드인지가 더 중요하다.**

## for loop 최적화

- O2 옵션으로 컴파일 시 조건문 계산 과정이 최적화된다.
- 반복 실행 내용이 일정할 경우, 컴파일러는 메모리 공간 크기 계산 및 할당을 예측할 수 있다.
- for 반복문에 컴파일 최적화 적용 시 컴파일러는 반복문 실행 결과를 사전에 계산하고 메모리에 저장한다.

## 상수(const) 최적화(다중 조건문)

- 컴파일 최적화 미적용 시 어셈블리어는 각 조건마다 판단하는 과정을 구현
- 컴파일 최적화 적용 시(O1) 컴파일러는 실행 결과가 상수인 경우 사전에 계산하여 메모리에 저장해 둔다.
    - 프로그램 실행 시 실질적으로 거치는 계산 과정만 컴파일되는 방식으로 최적화가 진행된다.

# 임베디드 C언어 포인터 활용

## 데이터 타입 별 포인터 접근법

## 포인터 연산

## 문자열과 포인터