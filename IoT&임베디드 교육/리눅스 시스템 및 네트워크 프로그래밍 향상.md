# 가상화 개요

- 다른 운영체제에서 사용하는 시스템 리소스를 사용하기 위해 가상화를 사용한다.
- 가상화 머신(Virtual Machine 등)은 호스트가 가지고 있는 컴퓨팅에 필요한 모든 리소스들을 추상화하여 게스트 머신에 할당한다.
- Samba 연결 : Windows 환경에서 Linux 운영체제의 파일들을 수정할 수 있다.
    - 실행 또는 탐색기 창에서 '\\{IP 주소}' 입력

# virtual machine 사용법

- 가상 머신을 최초로 만드는 경우 머신 탭 > 새로 만들기 선택
    - 가상 머신을 새로 만드려면 운영체제를 구성하는 파일들이 필요하다(.iso 파일).
- 이미지를 이용해 설치하는 경우 머신 탭 > 추가 선택
- 네트워크 어댑터를 '호스트 전용 어댑터'로 설정하면 호스트와 게스트 간 통신 전용 네트워크로 생성된다.

# PuTTY 접속

- VM에서 ifconfig를 입력해서 나오는 네트워크 IP 주소를 통해 PuTTY로 접속한다.
- PuTTY에서 세션을 복제해서 같은 접속 주소에서 다른 작업을 할 수 있다.
    - 서로 다른 작업을 실행한 경우 이를 별도로 동기화해주는 작업이 필요하다.

# Windows에서 접속

- \\{ip 주소} 를 입력하면 Windows에서 VM 네트워크에 접근 가능하다.
    - VM 파일들은 기본적으로 숨김 처리되어 있다(전문 사용자 및 개발자용).

# 리눅스 시스템 프로그래밍

## 리눅스 시스템(운영체제) 개요

- 커널이 하드웨어를 제어하고, 그 위에 APP을 생성한다.
- 개별 앱들은 커널을 통해서만 시스템의 하드웨어를 제어할 수 있다.
- 커널의 Device는 문자 디바이스(Character Device, I/O)와 블록 디바이스(Disk Device)로 구분될 수 있다.
- 디바이스 드라이버는 개별 앱들이 커널에 원활하게 접근할 수 있도록 커널을 설정하는 프로그램 및 소스 코드이다.
    - 디바이스 드라이버가 제공하는 API를 사용할 수 있다.

# 리눅스 커널의 기능적 구조와 세부 기능

## 커널의 세부 기능

- 프로세스 관리 : 프로세스의 생성 및 소멸, 프로세스 간 통신(IPC) 등
- 메모리 관리
- 장치 관리
- 네트워크 관리
- **리눅스는 기본적으로 모든 시스템을 파일 단위로 관리하며, 기본 형식은 .bin 등의 파일들로 구성된다.**

## 시스템 프로그래밍

### 시스템 콜 

- 사용자 공간의 App(응용 프로그램)은 커널 코드를 직접 실행하거나 커널의 데이터를 조작할 수는 없다.
- 다만 응용 프로그램이 커널 단위 시스템을 활용해야 할 때 *커널에서 설정된 공간을 일시적으로 허용*해줄 수 있는데, 이를 시스템 콜이라고 한다.
- 응용 프로그램이 시스템 콜을 사용할 때 커널에 보내는 매커니즘이 칩셋 아키텍쳐마다 다르다.
    - i386(인텔) : int 0x80
    - x86_64(윈도우 64비트) : syscall
    - ARM/EABI : swl 0x18

- 모든 시스템 콜은 인터럽트를 가진다.
    - 다만 시스템 콜이 호출하는 대상이 인터럽트는 아니다.(인터럽트 방식을 사용하는 것)
    - 시스템 콜이 커널을 호출하면, 별도의 인터럽트를 설정해 주지 않아도 자체적으로 인터럽트처럼 작동한다.

- 리눅스 앱에서 시스템 콜 파일을 open함으로써 시스템 콜을 호출할 수 있다.

# 리눅스의 파일

- 파일은 리눅스에서 가장 근본적이고 기본적인 추상화된 형식이다(Everything is a file).
- 파일의 상호 작용은 읽기, 쓰기, 실행 등이 있다.
- 파일을 이용한 작업을 수행하려면 먼저 **파일을 열어야 한다(open)**.
    - 파일을 열 때 목적(읽기/쓰기 등)을 함께 설정할 수 있다.
- 파일의 궁극적인 관리는 커널에서 관리하므로, 파일을 열 때도 커널에 요청이 간다.
    - 커널은 이 요청에 응답하여, 파일 디스크립터(fd)를 생성한다.
    - fd는 특정 파일의 인덱스 값으로, 한 프로세스는 여러 파일들을 읽을 수 있다.
    - fd 인덱스 번호는 3번부터 시작한다(0은 표준 입력, 1은 표준 출력, 2는 표준 에러).

## regular file

- 리눅스의 일반적인 파일이다.
- bytestream이라 부르는 선형 배열로 구성된 데이터 바이트를 담고 있다.
    - 리눅스에서는 기본적으로 파일에 대한 추가 구성 또는 형식이 지정되지 않는다.
- 파일을 읽을 때는 offset의 위치부터 시작하여, 파일 끝(EOF)까지 읽는다.
    - offset 값을 변경하여 데이터 크기 등을 조절하는 효과를 볼 수 있다.
- 커널은 같은 파일에 동시에 write 할 수 없도록 제어하는 역할을 수행한다.

## 디렉토리와 링크

- 디렉토리는 접근하고자 하는 파일에 대해 사용자 공간에게 이름을 제공하는 데 사용한다.
- 디렉토리는 파일을 저장하는 공간이다.
- 디렉토리는 메타데이터만 보유하고 있으며, 파일의 존재 위치 및 디렉토리 내 존재하는 파일 정보만 담고 있다.

## Hard Link와 Symbolic Link

- Hard Link는 파일(inode)에 대해 새로운 이름을 만드는 링크이다.
    - 디스크에 추가 데이터를 할당하지 않고 링크만 매핑한다.    
- Symbolic Link는 파일 이름에 대한 일종의 바로가기이다.

## 특수 파일

- Block device : 바이트 array에 접근, 사용자는 순서에 상관없이 array의 바이트에 접근 가능
- Named pipe : 파일 디스크립터를 통해 프로세스 간 통신을 위한 특수파일로 프로세스 생성
- Socket(Unix 도메인 소켓) : 프로세스 간 통신에 사용하는 파일, 인터넷 경유 시 IP 주소와 포트 번호 필요

# 리눅스의 파일 제어

- 리눅스의 많은 명령어들(open, write, access, chmod, mkdir 등)은 시스템 콜인 경우가 많다.
- 시스템 콜 및 커널 조작 API의 사용법을 숙지할 필요가 있다.
    - 필요에 따라 직접 만들 수도 있다.

- 프로세스 kill : kill {PPID} 입력

# 파일 열기

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(){
	// 파일 오픈 시 int open(const char *pathname, int flags, mode_t mode) 입력
	// int open(const char *pathname, int flags, mode_t mode);
	// 모드는 리눅스 파일 읽을 때 사용하는 모드값(십진수 형태)
	open("file01", O_CREAT, 0775);
}
```

- 환경 변수(PATH)는 기본적으로 '/usr/bin' 로 설정되어 있다.
- 파일 실행 시 상대 변수를 입력하면, shell이 $PATH에서 기본적으로 설정된 위치에서 상대 경로를 찾는다.

## 현재 위치에 상관없이 파일을 실행하려면?

1. 절대 경로 설정 : $PATH에 절대 경로 위치를 설정해 준다.
- 다만 절대 경로를 사용하면 ls 등의 기본 명령어에 오류가 생긴다.

```
export PATH=.:{path}
```

2. 프로그램이 실행되는 Shell 환경 통일(PATH 추가)
- 실행 파일을 환경 변수로 등록한다.

```
PATH=$PATH:$HOME/bin:/{sourcepath}
PATH=$PATH:/{filepath}
```

- 프로그램을 개발하는 Shell의 환경을 통일해야 서로 다른 장치와 상황에서도 일관적으로 실행될 수 있다.

```
source ~/.bashrc
```

3. a.out을 기본 PATH 위치에 복사
- 이 경우 sudo 코드로 실행하거나 root의 권한이 필요하다.

```
cp ~/{filepath} /usr/bin/
```

4. 시스템 커널 이용(파일 링크)
- 시스템 커널을 쓰는 경우 아키텍쳐에 의존성이 있다.

## 크로스 컴파일

- 동일한 운영 체제와 컴파일러를 사용해도, x86, ARM 등의 시스템 환경에 따라 어셈블리어가 달라진다.
- 크로스 컴파일 기능을 사용하면 같은 운영체제와 gcc를 활용하면 시스템 환경이 달라져도 문제 없이 컴파일해 줄 수 있다.

## umask

- 특정 디렉토리에서 파일 또는 디렉토리를 생성할 때 자동으로 권한 설정을 하는 명령어이다.
- umask 변경은 'umask {0xxx}'를 입력한다.
    - 예) umask 0002
    - 'help umask'를 입력하면 설명을 볼 수 있다.
    - umask를 설정하면 파일 생성 시 자동으로 마스킹된다.(예: 마스크 값이 2이면 쓰기 기능 배제)

# file open & create 함수

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(){
	int fd;
	umask(0);
	
	fd = open("file01", O_CREAT, 0666);
	if (fd == -1) {
		perror("open");
		exit(10);
	}
	printf("fd=%d\n", fd);
	
	fd = creat("/home/file01", 0666);
	if (fd == -1) {
		//fprintf(stderr, "Create Error : ");
		perror("create");	// permission denied
		exit(10);
	}
	printf("fd=%d\n", fd);
	
	return 0;
}
```

# man 명령어 조회

- 구체적인 시스템 콜 사용법을 조회하려면 'man {시스템 콜}' 을 입력한다.
- man 2 {명령어} 입력 시 시스템 콜에 대한 설명이 나온다.
- man 조회 시 OPEN()안에 있는 숫자가 1이면 명령어, 2면 시스템 콜, 3은 라이브러리이다.

# 데이터 설계

- 보안성 향상을 위해서는 관계자들만 아는 형식으로 데이터 format을 설정할 필요가 있다.
- bytestream, struct 등 다양한 형식으로 설계할 수 있다.

# 리눅스 프로세스 동작

## 기본 시스템 콜

- 내장 라이브러리 함수처럼 취급되는 시스템 콜 명령어다.
- open, read, write, close 등이 있다.

## 인터럽트

- 기본 인터럽트(Ctrl + C) : default 인터럽트로 처리됨

## signal() 함수

- signal(신호 종류, 이벤트 핸들러) 로 정의하여 사용한다.
    - 신호 종류는 [signal 목록](https://www.lesstif.com/system-admin/unix-linux-kill-12943674.html) 참조
    - 지원하는 신호 종류는 운영체제마다 다를 수 있다.

- 이벤드 핸들러 대신 기본 동작 매크로를 넣을 수도 있다.
    - SIG_TERM : 프로세스 종료(기본)
    - SIG_IGN : 신호 무시
    - SIG_CORE : 프로세스를 종료하면서 core dump 파일 생성
    - SIG_STOP : 프로세스 정지
    - SIG_CONT : 중지된 프로세스 재시작

- signal() 함수를 설정하면 인터럽트 조건을 커스텀할 수 있다.
- nohang error : hanger로 프로세스를 kill하는 기능 비활성화
- 반복문 안에 signal() 함수를 넣으면 kill -9를 제외한 옵션으로 프로세스를 끌 수 없게 만들 수 있다.

## 프로세스 종료(kill)

- kill (-신호번호) (프로세스 번호 또는 $pidof 파일명) 입력
```
kill -s KILL [pid]
kill -15 [pid]  // 기본 kill 명령어(기본값=-15)
kill $(pidof a.out)     // 프로세스 ID를 모르는 대신 실행 파일 이름은 아는 경우
kill -9 [pid]   // 프로세스 강제 종료
```
- 핸들러 함수나 kill 명령어 파라미터 등을 통해 프로세스를 죽이는 대신 다른 행동도 구현할 수 있다.
    - kill 시그널을 받은 프로세스의 기본 동작은 **종료**이다.

## 핸들러 함수 만들기

- signal()에 핸들러를 등록하면, **특정 신호를 입력받았을 때 특정 함수를 실행하도록 만들 수 있다**.
- 예기치 못한 오류가 발생했을 때, 오류 상황을 저장하고 프로세스를 종료해 버릴 수도 있다.

## Daemon으로 Systemd 만들기