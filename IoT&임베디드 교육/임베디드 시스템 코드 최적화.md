# ARM 개발 환경

## vim 개발 환경(Linux)

- 임베디드는 기본적으로 리눅스 운영체제 기반에서 개발이 진행된다.
- vi 편집기 사용에 익숙해지는 것이 유리하다.

# gcc 컴파일

- 고수준 프로그래밍 언어를 저수준 언어(어셈블리어)로 바꾸고, 이를 기계어로 다시 변환한다.
- 어셈블리어 명령어 구성에 따라 프로그램 실행 시간 등을 최적화할 수 있다.
- 명령어 : gcc -o{level} {options} {source files} {-o output file}

## 컴파일 최적화 옵션(강의자료 15p)

- gcc -O0 : 컴파일 시간 최적화(기본)
- gcc -O1(O) : 코드 크기와 실행 시간 최적화
- gcc -O2 : 코드 크기와 실행 시간을 O1보다 최적화
- gcc -O3 : O2를 포함한 대부분의 최적화
- gcc -Os(Oz) : O2 포함 코드 크기 최적화
- gcc -Ofast : O3 포함 코드 실행 최적화
- gcc -Og : O1 포함 디버깅 코드 생성

- 명령어 마다 코드 실행시간, 코드 크기, 메모리 사용, 컴파일 소요시간 등에 장단점이 있다.
(교육 자료 기준으로 +가 많을수록 유리, -가 많을수록 불리)

- 적절한 컴파일 옵션을 사용하면 어셈블리어로 변환된 코드의 볼륨의 효율성이 증가하고, 프로그램이 최적화된다.
- 컴파일 옵션은 O2 이하를 사용하는 것이 권장된다(O3부터는 표준에 맞지 않고, 오히려 오류가 발생할 수 있음).

## 어셈블리어 분석

- push : 32비트 운영체제 환경에서 이하 명령어를 32비트 단위로 변환하는 역할
- 어셈블리어를 cat으로 조회하면 기계어가 아스키 코드 형태로 출력된다.
- build.sh 파일을 조회하면(cat) 빌드 시 사용한 명령어를 조회할 수 있다.
- 어셈블리어 명령어의 앞쪽은 오퍼레이션 명령어, 뒤쪽은 처리하려는 명령, 괄호 안에 있는 내용은 점유하는 메모리 정보
- 컴파일 시 -save-temps 옵션을 추가해야 어셈블리어가 저장된다.(저장된 어셈블리어는 cat으로 조회 및 분석 가능)

## 어셈블리어가 최적화되는 원리(p16)

- CPU 구조 및 명령처리 과정을 이해하면 도움이 된다.
- CPU는 메모리의 데이터를 가져와서 레지스터에 보관하고, 레지스터의 데이터를 ALU를 통해 실행(연산)하여 그 결과를 메모리에 저장한다.
- 데이터는 항상 메모리에 존재하므로, 메모리에 접근하는 포인터를 적절히 관리하는 것이 중요하다.
- 컴파일러 최적화는 (빌드를 통해 생성되는) 응용 프로그램이 데이터 불러오기, 연산, 저장하는 데 거치는 절차 및 횟수를 최소화하는 과정이다.

## complie explorer 활용

- compile explorer[https://godbolt.org/] 이용 시 컴파일 환경과 조건을 입력하면 어셈블리어 결과를 조회할 수 있다.

## 우선 순위(실행 순서)가 바뀌면 안 되는 경우?

- 어셈블리어의 순서가 바뀌면 하드웨어의 우선 순위가 변경될 수 있다.
- 우선 순위를 고정해야 한다면 컴파일 시 별도의 옵션을 설정해 주어야 한다.

## 변수 레지스터(변수 선언 시 register 선언) 초기화

- register로 선언된 변수는 프로그램 동작 시 메모리를 거치지 않고 레지스터 단계에서 처리된다.
- 컴파일 시 O1 옵션 설정 시 register 키워드가 붙어 있지 않아도 register 변수를 바로 사용할 수 있도록 최적화가 진행된다.
- 일반적으로 빠른 연산이 필요한 변수의 경우 register 키워드를 사용하는 것이 좋다.
- 다만 최근에는 컴파일 성능이 향상되었으므로 굳이 register 옵션을 붙이지 않아도 알아서 최적화해 줄 수 있다.

## while 반복문 최적화

- 컴파일 최적화가 진행되지 않은 경우 어셈블리어는 while의 조건문이 true인 경우와 false인 경우로 나누어서 표현한다.
- 컴파일 최적화 적용 시 조건문이 변할 수 없는(결과가 확정인) 환경인 경우 while문을 생략할 수 있다.
    - 조건문이 확정적으로 false인 경우 조건문 안의 코드를 실행하지 않아도 되므로, 최적화 시 생략된다.

## volatile 최적화

- volatile이 붙은 코드는 컴파일러 최적화를 해 주지 않는다(조건문이 false 확정인 경우에도!).
- volatile 변수는 호출될 때마다 메모리에 직접 접근하므로 컴파일 최적화 대상이 아니다.

### volatile 최적화 2: volatile 변수와 auto 변수가 같이 있는 경우

- 컴파일 최적화가 적용되지 않은 경우 모든 조건문이 어셈블리어로 번역된다.
- 컴파일 최적화가 적용된 경우, auto 변수는 false 확정 시 최적화되며, volatile 변수는 항상 컴파일된다.
- 단, volatile 변수 앞에 무한 loop 등으로 인해 변수가 실행될 일이 없는 경우 생략된다.
- **volatile 여부보다 실행 및 변경될 여지가 없는 변수/코드인지가 더 중요하다.**

## for loop 최적화

- O2 옵션으로 컴파일 시 조건문 계산 과정이 최적화된다.
- 반복 실행 내용이 일정할 경우, 컴파일러는 메모리 공간 크기 계산 및 할당을 예측할 수 있다.
- for 반복문에 컴파일 최적화 적용 시 컴파일러는 반복문 실행 결과를 사전에 계산하고 메모리에 저장한다.

## 상수(const) 최적화(다중 조건문)

- 컴파일 최적화 미적용 시 어셈블리어는 각 조건마다 판단하는 과정을 구현
- 컴파일 최적화 적용 시(O1) 컴파일러는 실행 결과가 상수인 경우 사전에 계산하여 메모리에 저장해 둔다.
    - 프로그램 실행 시 실질적으로 거치는 계산 과정만 컴파일되는 방식으로 최적화가 진행된다.
    - **상수로 만들 수 있는 값은 미리 상수화한다.**

## static 변수

- static 변수는 컴파일 시 0으로 자동 초기화된다.
- auto 변수는 초기화하지 않은 경우 컴파일 시 임의의 값으로 초기화된다(쓰레기값).

## 인라인(inline) 함수

- 인라인 함수는 함수의 형태로 작성된 코드이므로, 일반 함수보다 실행 속도가 빠르다.
- 컴파일러는 인라인 함수 코드를 함수가 아닌 상수의 형태로 배치함으로써 프로그램을 최적화할 수 있다.
- 인라인 함수는 함수 내부 코드의 길이가 짧은 경우 효과적이다.
    - 함수의 코드 길이가 긴 경우 일반 함수로 구현하는 것이 효과적이다.

### 어셈블리어로 작성된 인라인 함수

- (최적화 미적용 시) 인라인 코드 분기가 발생하는 경우 '인라인 함수명:' 으로 시작하는 어셈블리어 코드가 작성된다.
- 최적화 적용 시 상수 최적화와 마찬가지로 상수 등의 값은 컴파일 단계에서 계산하여 메모리에 저장해 둔다.

### (추가) 굳이 인라인으로 선언해야 하나?

- 최신 컴파일러는 일반 함수도 길이가 짧은 경우 인라인 함수처럼 호출 없이 바로 실행된다.
- 다만 인라인 선언을 하지 않은 함수는 일단 어셈블리어로 코드가 작성된다.
- 실행 코드를 조금이라도 더 최적화하고 싶다면 inline을 명시해 주는 것이 좋다.
- static inline으로 선언하면 이상적인 최적화가 가능하다.

## 매크로 최적화

- 매크로 코드 실행 시, 인라인 함수처럼 호출 과정을 거치지 않고 바로 실행된다.
- static inline으로 선언한 함수와 매크로는 컴파일 최적화 과정에서 동일한 효과가 발생한다.
    - 컴파일 시 성능 측면에서도 static inline과 매크로는 동일하다.

- 매크로를 사용하면 프로그램 최적화에는 유리하지만 코드 가독성에서 불리하다.

## 구조체 최적화

- 구조체 최적화는 메모리와 많이 연관되어 있다.
- 구조체에 컴파일 최적화를 진행하면 성능 향상이 크게 발생하지는 않지만, 메모리 배치 등이 효율적으로 진행되는 효과는 있다.

### 구조체 padding

- C언어에서 코드 실행 시 데이터가 메모리에 배치되는 과정에서 메모리 경계 단위로 분리된다.
- 데이터 사이즈가 작은 경우 남는 비트 사이즈 만큼 padding을 추가한다.
- padding 단위는 운영체제 메모리 단위(32/64)에 따라 다르다.
    - 32비트 운영체제인 경우 32비트에 모자라는 만큼 메모리 경계까지 padding을 채운다.

- 문자열, 숫자 등의 데이터는 padding이 추가된 형태로 조합되어 바이트 단위(32비트 운영체제는 4바이트, 64비트 운영체제는 8바이트)로 조합되어, 자료형의 최소 단위가 된다.

### 매크로의 장단점

# 임베디드 C언어 포인터 활용

## 메모리 주소

- 메모리 주소는 메모리에 저장된 데이터 위치의 일련 번호다.
- 각 메모리 주소마다 1바이트의 데이터가 저장된다.
- Stack 형태로 저장되는 데이터는 메모리 위쪽(높은 포인터 주소값)부터 저장된다.
    - 각 공간은 일정한 단위로 메모리 공간이 나뉘며, 필요에 따라 메모리가 할당된다.

- 프로그램 실행 시 할당되는 메모리(Heap 등)는 누적될수록 메모리 주소값이 증가한다.

## 포인터 주소

- 포인터 주소는 해당 포인터가 점유하는 메모리 주소로, 16진수 정수(32비트)로 표현된다.
- 메모리 공간은 운영체제(커널)용 공간과 응용 프로그램(App)용 공간으로 나뉘어 관리된다.
- 포인터 주소의 자료형 크기는 포인터가 가리키는 자료형 및 데이터와 상관없이 4비트다.

## 데이터의 메모리 점유용량(size)

- 개별 문자(char)는 1바이트, 정수(int)는 숫자 하나당 4바이트를 차지한다.
    - 예) 5자리 숫자로 이루어진 정수는 20바이트(size 20)
- 포인터 주소의 크기는 자료형과 상관없이 일괄적으로 4바이트를 차지한다.
- char는 1바이트, int는 4바이트, long은 4바이트, long long은 8바이트

## 데이터 타입 별 포인터 접근법

- 정수 배열의 경우 배열의 각 값의 크기는 4이므로, (메모리 주소+4)는 다음 배열의 메모리 주소가 된다.

## 포인터 연산

- 배열을 가리키는 포인터 주소에 덧셈이나 뺄셈 연산을 하면, 문자열 길이를 조절하는 효과를 볼 수 있다.
    - 단, 포인터 주소 연산 시 배열의 인덱스 범위를 초과하면 안 된다.

## 문자열과 포인터

- 포인터는 문자열의 시작점을 가리키는 주소가 된다.

### 문자열의 길이를 계산할 때

- strlen()을 사용하지 않고 포인터 주소로 문자열 길이를 계산할 수 있다.
- 문자열 끝 기호(\0)를 가리키는 포인터 주소에서 문자 배열의 주소(첫 문자의 포인터)를 빼면 문자열의 길이가 된다.

```c
int get_strlen(char *string)
{
    char *eof = string;

    while (*eof != '\0')
    {
        *eof++;
    }
    //while (*eof++ != '\0'); // 이렇게 계산하면 실제 배열 길이보다 1 더 길게 나옴

    return string - eof;
}
```

## 포인터 배열

- 문자열은 항상 맨 끝이 NULL('\0')로 끝나야 한다.
- 문자열 생성 및 복사 시 포인터를 사용한다.
    - 문자열 복사 시 포인터 주소값을 복사하여, 가리키는 메모리 위치 변경을 통해 문자열 복사 효과를 구현한다.

### 문자열 비교 함수

- strcmp 비교 시 출력되는 결과는 아스키 코드 값의 차이이다.
    - 문자열이 동일한 경우 0, 동일하지 않은 경우 동일하지 않은 첫 배열의 문자 간 아스키 코드 값의 차를 반환한다.

### 배열로 선언한 문자열 vs 포인터로 선언한 문자열

- 포인터로 선언한 문자열의 경우, 포인터 값을 증감함으로써 문자열의 특정 문자를 가리키거나, 배열 길이를 조절할 수 있다.
- 배열로 선언한 문자열의 경우 배열 내 특정 문자를 가리키기 위해서는 인덱스 번호가 필요하다.

```c
int strcmp1(char *s, char *t)
{
    int i;
    for (i=0; s[i]==t[i]; i++)
    if (s[i] == '\0')
        return 0;
    return s[i] - t[i];
}

int strcmp2(char *s, char *t)
{
    for ( ; *s == *t; s++, t++)
    if (*s == '\0')
        return 0;
    return *s - *t;
}
```

### 문자열 컴파일 최적화

- 동일한 값의 문자열이 들어가는 경우, 컴파일러는 이를 문자열 상수로 취급하여 동일한 BSS 영역에 저장한다.
- 문자열이 상수화된 경우, 서로 다른 함수에서 문자열을 호출하는 경우에도 동일한 포인터 주소를 반환한다.

## 함수 포인터

### main 함수에 적용

- main 함수는 argc, argv[]를 받을 수 있다.
- 두 번째 입력 값(argv)를 *argv[]로 정의해 주면 여러 개의 단어들을 한 번에 정상적으로 입력받을 수 있다.
- 입력받은 값을 활용하려면 인덱스 번호를 **1**번부터 사용해야 한다.
    - 0번 인덱스의 값은 프로그램 실행 명령어(./*program_name*)이다.

```c
// 앞쪽부터 세기(인덱스 값 증가)
int main(int argc, char *argv[])
{
    int 1;
    for (i = 1; i < argc; i++)
        printf("%s%s", argv[i], (i < argc - 1) ? " " : "");
    printf("\n");
    return 0;
}
```

- **포인터 주소 연산의 최소 단위는 포인터 자료형의 크기이다.**
    - 예를 들어 포인터가 가리키는 자료형의 크기가 4라면, 포인터 주소에 1을 더하는 경우 실제 주소값은 4만큼 증가하고, 1을 빼는 경우 주소값은 4만큼 감소한다.

```c
// 최대 길이(argc)와 비교(포인터로 조회)
int main(int argc, char *argv[])
{
    // argc 값을 1씩 줄이면서 argv 포인터 위치 이동
    while (--argc > 0)
        printf((argc > 1) ? "%s " : "%s", *++argv);
    printf("\n");
    return 0;
}
```

## 다중 배열 포인터

### 다중 배열 만들기

- 다중 배열 생성 시 메모리 포인터를 사용하면, 배열 길이를 명시하지 않아도 정상적으로 다차원 배열을 선언할 수 있다.
    - 포인터를 사용하지 않는 경우 하위 차원 배열의 크기를 명시해 주어야 한다.

```c
char *pmsg[] = {arr1, arr2, arr3, arr4};
```

- 포인터로 선언한 다차원 배열의 총 크기는 (4 * 하위 배열 크기)가 된다.
- 이중 배열로 선언한 다차원 배열의 총 크기는 (4 * 상위 배열 크기 * 하위 배열 크기)가 된다.

- 추가 : C언어 조건문도 삼항 연산자로 표현 가능하다.

```c
char *month_name(int month)
{
    // (조건문) ? 조건이 참인 경우 : 조건이 거짓인 경우
    return (month < 1 || month > 12) ? name[0] : name[i];
}
```

## 함수 포인터를 다른 함수에 넣기

- 함수 포인터라는 것을 알려주는 용도로 포인터 변수를 괄호 안에 감싸서 표시한다.
- **메뉴 구조의 프로그램**인 경우 함수를 배열 형태로 저장한 후 포인터로 조회하면 간단하고 효율적인 프로그램 구현이 가능하다.
    - 길이가 길고 복잡한 switch 구문을 구현할 필요가 없어진다.

```c
#include <stdio.h>
char fn_test1 (int ia)
{
    printf("fn_test1: %d\n", ia);
    return 'A';
}

char fn_test2 (int ia)
{
    printf("fn_test2: %d\n", ia);
    return 'B';
}

char fn_test3 (int ia)
{
    printf("fn_test3: %d\n", ia);
    return 'C';
}

int main(void)
{
    // (*pfn[])(int)는 배열 안의 함수들은 char 형태의 데이터를 반환하고, int 형태의 데이터를 입력받음을 명시한다.
    char (*pfn[])(int) = {fn_test1, fn_test2, fn_test3};
    char ch;
    int sw = 2;

    ch = pfn[sw](70);
    printf("ch=%c\n", ch);  // C
}
```