# Vector vs Deque

- 일반적인 경우 Deque가 더 유리하다.
- 다만 공간지역성(3차원 등)을 고려해야 하는 경우 Vector가 더 유리하다.

# 배열(리스트)

- 배열에 수정 사항(삽입 및 삭제)이 적용되는 경우 수정된 인덱스의 뒤쪽에 있는 값들은 한 칸씩 이동한다.(공간복잡도 O(n))
- 데이터 조회가 많은 경우 유리한 구조다.


# 연결 리스트(Linked List)
- 각 노드가 데이터(값)와 포인터(다음 노드의 주소)를 가지고 한 줄로 연결된 형태의 리스트이다.
- 연결 리스트의 경우 데이터가 산발적으로 존재한다.
  - 조회 시에 난해한 점이 있지만, 수정 및 삭제하는 경우 수정된 인덱스의 관계(가리키는 위치)를 수정하면 된다.
- 데이터의 삽입/삭제가 잦은 경우 유리하다.

# Vector

- 데이터 조회 시 유리하나(_O(1)_) 삽입 및 삭제 시 불리하다(_O(N)_)
- 데이터가 동적으로 변화한다.
- Java에서는 보통 배열과 연결 리스트를 많이 사용한다.

# Deque

- 컨테이너 앞/뒤의 데이터를 빠르게 수정할 수 있는 자료구조이다.

# 자기 균형 이진 탐색 트리

- 트리의 자식 수 균형을 최대한 맞춘 형태
- 자식 수는 최대 2로 가정한다.
- _o(log n)_ 의 시간복잡도를 가진다.

# set, map

- set은 중복되지 않는 값을 가진다.
- map은 중복을 허용하되, key와 value 쌍을 가진다.
- 데이터 조회와 수정이 균형 있게 진행되는 경우 유리하다.

# 해시

- 시간복잡도가 _o(1)_ 에 근접한다.

# 우선 순위 큐(primary_queue)

- 먼저 들어온 데이터가 아니라 **우선순위가 높은 데이터** 가 우선 나간다.
- 컨테이너를 최대 힙으로 유지한다.(힙을 이용해 구현)
  - 힙은 이진 트리를 이용해 구현
- 최댓값, 최솟값을 찾을 때 유리하다.
