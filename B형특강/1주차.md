# Vector vs Deque

- 일반적인 경우 Deque가 더 유리하다.
- 다만 공간지역성(3차원 등)을 고려해야 하는 경우 Vector가 더 유리하다.

# 배열(Array)

- 배열에 수정 사항(삽입 및 삭제)이 적용되는 경우 수정된 인덱스의 뒤쪽에 있는 값들은 한 칸씩 이동한다.(공간복잡도 O(n))
- 크기 조절이 불가능하다(Python 제외), 크기를 바꾸려면 새로 정의해야 한다.
- 데이터 조회가 많은 경우 유리한 구조다.


# 연결 리스트(Linked List)
- 각 노드가 데이터(값)와 포인터(다음 노드의 주소)를 가지고 한 줄로 연결된 형태의 리스트이다.
- 순차 접근만 가능하다.
- 수정 및 삭제하는 경우 노드 간 관계(인접한 노드가 가리키는 위치)를 수정하면 된다.
- 데이터의 삽입/삭제가 잦은 경우 유리하다.
  - 단, 수정 시 **순서를 정의하는 경우** 시간복잡도가 o(N)이 된다.

# Vector

- 데이터 조회 시 유리하나(_O(1)_) 삽입 및 삭제 시 불리하다(_O(N)_)
- 데이터가 동적으로 변화한다.
- Java에서는 보통 배열과 연결 리스트를 많이 사용한다.

# Deque

- 컨테이너 앞/뒤의 데이터를 빠르게 수정할 수 있는 자료구조이다.

# 자기 균형 이진 탐색 트리

- 트리의 자식 수 균형을 최대한 맞춘 형태
- 자식 수는 최대 2로 가정한다.
- _o(log n)_ 의 시간복잡도를 가진다.

# set, map

- set은 중복되지 않는 값을 가진다.
- map은 중복을 허용하되, key와 value 쌍을 가진다.
- 데이터 조회와 수정이 균형 있게 진행되는 경우 유리하다.

# 해시

- 시간복잡도가 _o(1)_ 에 근접한다.

# 우선 순위 큐(primary_queue)

- 먼저 들어온 데이터가 아니라 **우선순위가 높은 데이터** 가 우선 나간다.
- 컨테이너를 최대 힙으로 유지한다.(힙을 이용해 구현)
  - 힙은 이진 트리를 이용해 구현
- 최댓값, 최솟값을 찾을 때 유리하다.

# 비트마스킹

- 각 배열의 값을 비트(이진수)로 전환
- 두 배열 간 비교를 할 때 배열의 각 인덱스를 하나씩 대조하는 대신 각 배열의 값을 2 ** (인덱스 번호)로 계산 후 비교할 수 있다.
- 예) 친구 관계를 구하는 문제에서, 각 인물(요소) 간 관계를 반복해서 구할 수도 있지만, 비트마스킹을 이용해 이진수로 관계를 저장할 수도 있다.

# 정적 할당

- 노드의 최대치를 선언하는 방법(예: 10000, 999999)