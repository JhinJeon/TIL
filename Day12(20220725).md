## 월말평가 오답노트

### 아스키 코드 인덱스

문제의 코드 :

```python
def caesar(char, n=5):  # char = 입력받은 문장
    new_pw = []  # 암호화된 비밀번호를 반환받을 리스트
    for k in char:  # char의 각 문자를 k로 반환
        encoded = ord(k)+n  # 인코딩 : n만큼 민(더한) 결과를 아스키 코드로 저장
        if encoded > 122:   # 밀어낸 결과가 122(소문자 z)를 벗어나는 경우
            encoded -= 25   # 소문자 a부터 시작하도록 리셋
        elif encoded > 90 and encoded < 97:  # 밀어낸 결과가 90(대문자 Z)을 벗어나는 경우
            encoded -= 25   # 대문자 A부터 시작하도록 리셋
        new_pw.append(chr(encoded))  # chr()로 아스키 코드를 암호화된 문자열로 반환
    answer = ''.join(new_pw)    # 암호화된 결과를 단일 문자열로 반환
    return answer
```

문제점

- n에 26보다 큰 값이 입력됐을 때 알파벳이 아닌 다른 문자를 반환하는 문제가 있음
- (n=5 기준) v, w, x, y, z를 입력 받았을 때(대문자 포함) 원래 출력되어야 하는 문자(a,b,c,d,e)의 한 칸 더 뒤의 값(b,c,d,e,f)을 반환하는 문제가 있음

해결 방안

- 기존 코드의 encoded -= 25 를 encoded -= (n % 26)으로 수정

## 파이썬 매서드

- 매서드에 (필수 인자와 선택 인자) 입력

### 파이썬 공식 문서의 표기법

```python
str.replace(old,new,[,count])
```

- old와 new는 필수 인자(없으면 오류 발생)
- [,count]는 선택 인자(없어도 실행 가능)

## 문자열(string type)

- 문자들의 나열
- 모든 문자는 str 타입
- 변경 불가능(immutable)
- 큰 따옴표나 작은 따옴표로 묶어서 표시

## 메서드 모음

- id(chr) : chr의 메모리 주소 확인
- s.find(x) : 문자열 s에서 문자 x의 첫 번째 위치 인덱스 반환, 없으면 -1 반환
- s.index(x) : 문자열 s에서 문자 x의 첫 번째 위치 인덱스 반환, 없으면 오류 발생
- s.isalpha(): s가 알파벳 문자인지 확인(한글도 True 반환)
- s.title() : s가 제목 형식인지(첫 문자만 대문자, 나머지 문자는 소문자)인지 확인
- s.strip([chars]) : s의 좌우에 있는 chars에 입력된 문자열을 제거, 기본값 공백
- s.split(sep=None,maxsplit=-1) : 문자열을 특정 단위로 나누어 리스트로 반환
  - sep=은 기본값 None, 특별한 값을 입력하지 않으면 공백을 기준으로 분할
  - maxsplit=은 최대 분할 수, -1 입력 시 분할 수 제한 없음
- s.swapcase() : 문자열 s의 대문자를 소문자로, 소문자를 대문자로 변환 

## 리스트(list)

- 가변 자료형(생성 후 부분 변경 가능)
- 리스트 안에 리스트 입력 가능

## 리스트 관련 메서드

- L.remove : 리스트 L의 가장 왼쪽에 있는 항목 제거, 항목이 없으면 ValueError
- L.pop : 리스트 L의 가장 오른쪽에 있는 항목을 반환한 후 제거
- L.inster(i,v) : 리스트의 i번째 인덱스에 항목 v 삽입
  - i에 (리스트 길이-1)보다 큰 값을 입력하면 리스트의 가장 오른쪽에 삽입됨
- L.extend(m) : 순회형 m의 모든 항목들을 리스트 끝에 추가 (+= 와 동일)
- L.index(x, start, end) : 리스트 항목들 중 가장 왼쪽에 있는 항목 x의 인덱스 값 반환
  - start와 end로 탐색 범위 설정 가능
- L.count(x) : 리스트에서 항목 x의 개수 반환(항목 x가 없으면 ValueError)
- L.sort() : 리스트를 sort()안에 입력한 기준에 따라 정렬
  - 선택 인자로 reverse=True 입력 시 내림차순 정렬
  - <u>별도의 변수에 저장</u>하고 싶으면 **sorted(L)** 사용
- L.reverse() : 리스트를 **반대로** 정렬
  - 순서만 반대로 읽는 것
  - 그 외의 별도의 정렬 작업은 없음
  - 원본을 *수정*하는 메서드

## 튜플

- 여러 개의 값을 순서가 <u>있는</u> 구조로 저장
- 생성 후 담고 있는 자료를 변경할 수 없음
- 소괄호 형태로 사용

## 셋(set)

- 순서가 없는 데이터의 묶음
- 중복되는 요소가 있으면 한 가지만 저장(중복 불가)
- 수학의 집합과 같은 개념
- 가변 자료형(값 변경 가능)

> **주의 : 빈 셋을 생성할 때 '{}'를 사용하면 딕셔너리 타입으로 인식됨**
> 
> - 빈 셋을 만들 때는 set() 메서드 사용

## 셋 관련 메서드

- s.copy() : 셋의 <u>얕은 복사본</u> 반환
- s.add(x) : 셋에 x 추가
- s.remove(x) : 셋에서 x를 제거, 비어있는 경우 KeyError 반환
- s.pop() : 셋에서 무작위 항목을 반환한 후 제거, 빈 셋일 경우 KeyError 반환
- s.update(t) : 셋 t에 있는 모든 항목들 중 셋 s에 없는 항목 추가
- s.clear() : 모든 항목 제거
- s.isdisjoint(t) : 셋 s와 셋 t에 겹치는 항목이 있는지 확인
  - 중복되는 것이 없다면 True 반환
- s.issubset(t) : 셋 s가 셋 t의 하위 셋인 경우 True 반환
- s.issuperset(t) : 셋 s가 셋 t의 상위 셋인 경우 True 반환
- s.discard(x) : 셋에서 x값 삭제, 셋에 x값이 없어도 에러가 발생하지 않음

## 추가 : 얕은 복사 vs 깊은 복사

- 대입 연산자( = ) : 해당 객체의 참조를 복사
  - 참조 복사 : 원본의 데이터 주소를 복사해 오는 것
  - 참조 복사의 경우 원본이 바뀌면 복사본도 바뀜

- 얕은 복사 : 같은 원소를 가진 연산된 결과를 *다른 주소로* 복사
- 깊은 복사 : 원본 전체를 별개의 주소에 벌개의 객체로 저장
  - 메모리 사용량이 많아지는 문제가 있음

## 보충수업

- vsc에서 코드 즉시 실행 : ctrl  + F5
- 단일 변수에 쉼표 단위로 값을 저장하면 자동으로 tuple로 분류됨
- 
```python
a = 1,2,3,4,5
print(type(a)) # tuple
```