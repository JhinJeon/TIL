🔔목차🔔

- [자료 구조](#자료-구조)
- [스택](#스택)
  - [스택의 특징](#스택의-특징)
  - [스택의 구현을 위해 필요한 자료구조](#스택의-구현을-위해-필요한-자료구조)
  - [연산](#연산)
  - [스택의 응용](#스택의-응용)
  - [재귀호출](#재귀호출)
  - [재귀함수의 조건](#재귀함수의-조건)
  - [다이나믹 프로그래밍(DP)](#다이나믹-프로그래밍dp)
  - [그래프에 대한 이해](#그래프에-대한-이해)
  - [인접한 정점 목록을 바탕으로 그래프 표현하기](#인접한-정점-목록을-바탕으로-그래프-표현하기)
  - [DFS 구현 시 필요 사항](#dfs-구현-시-필요-사항)
  - [재귀 함수의 원리](#재귀-함수의-원리)
- [- 값을 반환할 때는 콜 스택에 쌓인 순서의 역순으로 반환](#--값을-반환할-때는-콜-스택에-쌓인-순서의-역순으로-반환)
  - [다이나믹 프로그래밍(DP)](#다이나믹-프로그래밍dp-1)
  - [DP 예시: 피보나치수열](#dp-예시-피보나치수열)
  - [깊이 우선 탐색(DFS)](#깊이-우선-탐색dfs)
  - [DFS 구현](#dfs-구현)
  - [너비 우선 탐색(BFS)](#너비-우선-탐색bfs)

# 자료 구조

- 자료 : 메모리에 저장되는 값(정수, 실수, 문자 등)
- 자료 구조 : 메모리에 저장되는 데이터, 데이터 연산 기능 제공
- 자료 구조의 특징을 알아야 알고리즘 작성 가능

# 스택

## 스택의 특징

- 데이터를 한쪽에서만 넣고 빼는 자료구조
- 선형적인 구조 : 자료 간의 관계가 1대 1의 관계를 가진다.
- 후입선출(Last-In-First-Out) : 마지막에 삽입한 자료를 가장 먼저 꺼낸다.
- 페이지 뒤로 가기, 실행 취소 등에 응용 가능

<br>

## 스택의 구현을 위해 필요한 자료구조

- 자료구조 : 자료를 선형으로 저장할 저장소
  - 배열 사용 가능
  - 저장소 자체를 스택이라고 부르기도 한다.
  - 스택에서 마지막으로 삽입된 원소 위치를 top(stack pointer)라고 부른다.

## 연산

- 삽입 : 저장소에 자료를 저장
- 삭제 : 저장소에서 자료를 꺼내기(순서는 삽입한 자료의 역순)
  - 삭제는 pop 사용
  - pop은 빈 스택에서 동작할 수 없으므로, 먼저 해당 스택이 비어있는지 확인해야 함
- isEmpty = 스택이 공백인지 확인하는 연산
  - 비어 있으면 True, 비어 있지 않으면 False
- peek = 스택의 top에 있는 item 반환

## 스택의 응용

1. 괄호 검사

- 문자열을 구성하는 괄호들을 차례대로 조사
- 왼쪽 괄호를 만나면 스택에 삽입, 오른쪽 괄호를 만나면 스택에서 삭제(top 괄호 제외) 후 오른쪽 괄호와 짝이 맞는지 검사
    - 스택이 비어 있거나 괄호의 짝이 맞지 않으면 조건 위배


## 재귀호출

- 자기 자신을 호출하여 순환 실행하는 호출 방식
- 프로그램의 크기를 줄이고 간소화하기 좋음
- 반복호출의 깊이가 지나치게 깊으면 안 됨(input 값이 작은 얕은 깊이에서만 사용)
- call tree를 그리면 재귀함수 구성에 도움이 됨

<<<<<<< HEAD
## 재귀함수의 조건

- 종료 조건(Base case) : 무한 호출, 최대 깊이 초과 방지
- 점화식(재귀식) : 상위 문제를 해결하기 위해 해결할 하위 문제 범위 설정

## 다이나믹 프로그래밍(DP)

- Memoization : 별도의 자료 구조에 미리 저장해 두었다가 사용하는 방식

```python
memo = [0,1]

def fibo(n):
  if len(memo) <= n:
    memo.append(fibo(n-1) + fibo(n-2))
  return memo[n]
```

## 그래프에 대한 이해

- 정점(노드) : 간선으로 연결되는 객체
- 간선(엣지) : 정점 간의 관계(연결)을 표현하는 선
- 경로 : 시작 정점부터 도착 정점까지 거치는 정점들(시작 정점과 도착 정점 포함)
- 인접 : 두 개의 정점이 하나의 간선으로 직접 연결된 상태

## 인접한 정점 목록을 바탕으로 그래프 표현하기

- 인접 행렬 또는 인접 리스트로 표현
  - 인접 행렬은 이차원 행렬 리스트에서 간선이 없으면 0, 있으면 1로 표현
  - 인접 리스트는 인덱스 번호가 정점, 인덱스의 값은 인접한 정점
- 인접 행렬은 직관적이고 만들기 편리함
- 인접 리스트는 효율적임

## DFS 구현 시 필요 사항

1. 인접 관계를 표현할 그래프
2. 방문 처리용 리스트

## 재귀 함수의 원리

- 함수는 호출 시 콜 스택에 쌓임
- 값을 반환할 때는 콜 스택에 쌓인 순서의 역순으로 반환
=======
## 다이나믹 프로그래밍(DP)

- 최적화 문제를 해결하는 알고리즘
- 알고리즘 자체보다는 문제 해결의 접근법에 가까움
- 입력 크기가 작은 문제를 해결한 다음 그 해들을 이용하여 입력 크기가 큰 문제를 해결
  - 최종적으로 원래 주어진 문제를 해결
  

## DP 예시: 피보나치수열

```python
def fibo_dp(n):
  table[0] = 0
  table[1] = 1
  for i in range(2, n+1):
    table[i] = table[i-1] + table[i-2]
  return table

table = [0] * 101
fibo_dp(100)  # 6765
```

## 깊이 우선 탐색(DFS)

- 그래프로 표현된 모든 자료를 빠짐없이 검색하는 방법 중 하나
- 시작 정점 중 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색
  - 더 이상 갈 곳이 없으면 가장 마지막에 만났던 갈림길 정점으로 되돌아와 다른 방향 탐색
  - 이 과정을 거쳐 모든 정점을 방문하는 순회 방법
- 후입선출 구조의 스택(stack) 사용

## DFS 구현

- 초기 상태 : 배열 visited를 False로 초기화하고 공백 스택 생성
- 시작 정점을 기준으로 깊이 우선 탐색 시작
  - 탐색 완료 지점은 visited의 해당 인덱스의 값을 True로 전환
  - 인접한 방문하지 않은 정점이 있으면 현재 위치를 스택에 push하고 하위 탐색 계속
- 탐색 우선순위가 동일할 때는 사전에 설정한 기준에 따라 탐색(문자열 오름차순 등)

## 너비 우선 탐색(BFS)

- 그래프로 표현된 모든 자료를 빠짐없이 검색하는 방법 중 하나
