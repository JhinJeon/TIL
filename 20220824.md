# 큐(Queue)

- 삽입과 삭제의 위치가 제한적인 자료구조(선입선출)

## 큐 사용을 위해 필요한 연산

- enQueue : 큐의 뒤쪽에 다음 원소 삽입
- deQueue : 큐의 앞쪽에서 원소 삭제 후 반환(pop)
- createQueue : 빈 큐 생성
- isEmpty : 큐가 비었는지 확인
- ifFull : 큐가 가득 찼는지 확인
- Qpeek : 큐의 앞쪽에서 <u>원소 삭제 없이</u> 값 반환

## 선형 큐

- 1차원 배열 이용
- 큐의 크기는 배열의 크기(길이)
- 첫 번째 인덱스를 front, 마지막 인덱스를 rear로 표시

- 초기 상태 : front == rear == -1
- 공백 상태 : front == rear
- 포화 상태 : rear == n - 1(마지막 인덱스와 동일)


## 삽입(enQueue)

- rear 값을 1 증가시켜 새로운 원소를 삽입할 자리 마련
- 해당 rear 값에 원소 저장

```python
def enqueue(item):
    global rear
    if isFull() : print('Queue Full!')
    else{
        front <- front + 1;
        return Q[front];
    }
```

## 선형 큐 이용 시 발생하는 문제 : rear 인덱스 값 갱신

1. 매 연산마다 배열의 모든 값들을 한 칸씩 앞으로 이동 : 원소 이동에 많은 시간 소요, 비효율적
2. 논리적으로 처음과 끝을 연결(원형 형태로 작동하게 구성)
   - front는 항상 비워둠
   - 배열 길이로 나눈 값의 나머지로 인덱스 번호 결정

## 우선순위 큐

- 우선 순위를 가진 항목들을 저장하는 큐
- 선입선출이 아니라 우선순위가 높은 순서대로 값이 반환(pop)됨
- 배열 또는 리스트로 구현

# 큐의 활용

## 버퍼

- 데이터를 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역
- 버퍼링 : 버퍼를 활용하는 방식, 버퍼를 채우는 동작
  - 버퍼링 중 화면이 멈추는 경우 : 버퍼가 완전히 비어 있고 새로 채우는 동작이 느리기 때문

- 버퍼의 자료 구조 : 일반적으로 입출력 및 네트워크 관련 기능에서 이용
  - 선입선출(FIFO) 방식을 활용해야 하므로 큐 사용


# 너비 우선 탐색(BFS)

- 인접한 정점들을 모두 방문한 후, 방문했던 정점에서 인접한 정점들을 차례대로 방문
- 선입선출 형태의 자료구조 필요 : 큐 사용

## BFS 예시

```python
def BFS(G, v, n): # G는 그래프, v는 탐색 시작점
  visited = [0] * (n+1)
  queue = []
  queue.append(v)
  visited[v] = 1
  while queue:
    t = queue.pop(0)  # 큐의 첫 번째 원소 반환
    visit(t)
    for i in G[t]:
      if not visited[i]:
        queue.append(i)
        visited[i] = visited[n] + 1 # n으로부터 1만큼 이동

```