절차지향 프로그래밍 : 호출된 순서에 따라 작동하는 프로그램

객체지향 프로그래밍 : 프로그램의 확장성 고려

객체는 역할, 책임, 협력을 갖고 있음

추상화, 캡슐화, 다형성, 상속은 원래 추상화에서 기원한 것

- 추상화 : 불필요한 복잡한 것을 숨기고 필요한 것들만 단순하게 보여주는 것
  - 요청을 줬을 때 반응만 해 주면 충분(처리하고 반응하는 과정까지 알 필요 없음)

- 캡슐화 : 각 객체는 자율적으로 동작하므로, 객체의 동작에 간섭하면 안 됨
  - 다른 객체의 내부에 관여 불가
  - 객체에 자율성 부여
  - 추상화에서 기인하는 특징

- 다형성 : 다른 객체에게 요청해도 결과만 동일하면 문제 없음

- 상속 : 객체들은 하나의 클래스에서 파생된 인스턴스라는 공통점이 있음
  - 클래스 간의 상속도 가능


책임 == 행위 == 메서드

- 타입 : 서로 다른 객체들을 하나로 추상화한 형태
  - 클래스는 객체를 타입으로 추상화시키는 명령어

- 속성 : 특정 데이터 타입(클래스)의 객체들이 가지게 될 상태/데이터
- 클래스 변수와 인스턴스 변수 존재

클래스 변수 : 한 클래스에서 모든 인스턴스가 공유하는 값
-  같은 클래스의 인스턴스들은 같은 클래스 변수 값을 갖게 됨

이름 공간: 클래스를 정의하면 클레스와 해당하는 이름 공간 생성
인스턴스를 만들면 객체와 namespace 생성
인스턴스 - 클래스 순으로 탐색

self : 인스턴스 객체가 생성될 때 자동으로 호출되는 메서드
- 인스턴스 변수들의 초기값을 설정
= \_\_init__ self: 

매직 메서드
- 특별한 상항에서 쓰임
- 인스턴스에서 직접 호출하지 않아도 결과를 즉시 반영하는 메서드
- 생성자, 소멸자 모두 매직 메서드

소멸자 메서드
- 인스턴스 객체가 소멸되기 전에 호출되는 메서드
- 프로그램이 끝나면 인스턴스도 소멸
```python
class Person:

  def __del__(self):
    print('인스턴스가 사라졌습니다.')

person1 = Person()
del person1 # 인스턴스가 사라졌습니다. 출력
```

del : 변수가 객체를 가리키는 참조값을 제거(== 포스트잇 떼기)

## 클래스 메서드

- 클래스가 사용하는 메서드
- 데코레이터 필요 (@classmethod)
- 첫 번째 인자로 self가 아니라 cls를 입력

```python
class MyClass:

  @classmethod
  def class_method(cls):
    pass
```


## 데코레이터(@)

@classmethod (클래스메서드) : 클래스 내의 변수를 사용할 때

클래스 메서드 활용 : 인스턴스에서 Person.count += 를 정의하는 경우 개별 인스턴스 내에서 별도로 클래스 변수를 계산

@staticmethod (스태틱메서드) : self를 입력할 필요가 없는 경우(모든 인스턴스에서 일정한 값을 반환해야 하는 경우) 사용

```python
@staticmethod
def hello():
  return 'Hello!'
```

## 매서드 오버라이딩

- 부모 클래스의 메서드를 불러와서 특정 기능을 변경하고 싶을 때 사용
- 부모 클래스의 인스턴스와 동일한 이름의 인스턴스를 생성한 후 다르게 정의

super(). : 상위 클래스의 인스턴스를 그대로 불러오기
super() 이하에 별도의 코드를 작성하면 기존 인스턴스에 추가로 무언가를 할 수 있음

## 캡슐화

### Public Member

- 일반적인 클래스/인스턴스 속성

### Protected Member

- Public과 Private의 중간 지점
- 클래스 외부에서도 접근은 가능하나 (암묵적으로) 권장되지는 않음
- 느슨한 제한

### Private Member

- 클래스 내부에서만 사용 가능
- 하위 클래스 상속 및 호출 불가
- 외부 호출 불가
  - 엄밀히 따지면 '불가능한 것처럼 보이게' 하는 것


## Property Decorator

- 원칙적으로 클래스 내의 정보들을 외부에서 직접 접근할 수 **없음**
- 다만 클래스 내에 @Property를 설정하는 경우 클래스명.인스턴스()를 입력해도 원하는 값을 반환하게 할 수 있음

```python
class Age:
  def __init__(self, age):
    self._age = age
  
  @property # getter(property decorator)
  def age(self):
    return self._age
  
  @age.setter # setter
  def age(self, new_age):
    if new_age <= 19:
      raise ValueError()
      return

    self._age = new_age

a1 = Age(20)
print(a1.age)   # 20
```

## 궁금한 점

- self는 클래스 인스턴스의 일종 : 클래스 내에서 필요한 정보들을 찾음
- @staticmethod() 이하의 인스턴스는 self를 입력받지 않기 때문에 클래스 내의 다른 인스턴트나 변수들을 참조하지 않음
  - 이 경우 인스턴스 내의 함수나 변수 등을 활용하여 자체적으로 처리 시도

...인 줄 알았는데 상위 클래스에서 정보만 참조하고 받아오지는 않는 건가?